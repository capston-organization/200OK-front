<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>ë§ë¡±ì´ì˜ ê³¼ì¼ ì°¾ê¸° (ë°°ì¹˜ ìœ ì§€ + ë²„ê·¸ ìˆ˜ì •)</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        background: #000;
      }
    </style>
  </head>
  <body>
    <script>
      const SCALE = {
        // ìŠ¤í”„ë¼ì´íŠ¸ í¬ê¸° ì¡°ì ˆí•˜ëŠ” ê³³
        POCKET: 1.0,
        MALONG: 1.0,
        BOWL: 1.0,
        TABLE: 1.0,
        TIMER: 1.0,
      };

      class GameScene extends Phaser.Scene {
        constructor() {
          super("GameScene");
          this.score = 0;
          this.gameTime = 40;
          this.gameTimer = 40;
          this.isGameStarted = false;
          this.isGameOver = false;
          this.pockets = [];
          this.currentAnswer = 0;
          this.consecutiveCorrect = 0;
          this.isProcessingTurn = false; // ğŸ’¡ ì¤‘ë³µ í´ë¦­ ë°©ì§€ í”Œë˜ê·¸
          this.fruitStep = 0; // ğŸ’¡ ê³¼ì¼ ë‹¨ê³„ ë³€ìˆ˜
        }

        preload() {
          // ì´ë¯¸ì§€ë¥¼ ë¡œë”©í•˜ëŠ” ë¶€ë¶„ì…ë‹ˆë‹¤.
          this.load.setPath("assets/Sprites/");

          this.load.image("background", "Background.png");
          this.load.image("quiz_board", "QuizBoard.png");
          this.load.image("quiz_icon", "QuizIcon.png");
          this.load.image("timer_graphic", "timerGraphic.png");
          this.load.image("table", "table.png");

          this.load.image("malong_default", "malong_default.png");
          this.load.image("malong_sad", "malong_sad.png");
          this.load.image("malong_happy", "malong_happy.png");

          this.load.image("defaultPack_lock", "defaultPack_lock.png");
          this.load.image("defaultPack_open", "defaultPack_open.png");
          this.load.image("goodPack_lock", "goodPack_lock.png");
          this.load.image("goodPack_open", "goodPack_open.png");

          this.load.image("bowl0", "bowl0.png");
          for (let i = 1; i <= 15; i++) {
            this.load.image(`bowl${i}`, `bowl${i}.png`);
            this.load.image(`fruit${i}`, `fruit${i}.png`);
          }
        }

        create() {
          // ê²Œì„ì„ 1920x1080 í¬ê¸°ë¡œ ìƒì„±í•©ë‹ˆë‹¤. ê²Œì„ ìŠ¤í”„ë¼ì´íŠ¸ë“¤ì˜ ìœ„ì¹˜ì™€ í¬ê¸°ë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
          const gameWidth = 1920;
          const gameHeight = 1080;
          const centerX = gameWidth / 2;

          // 1. ë°°ê²½
          this.add
            .image(centerX, gameHeight / 2, "background")
            .setDisplaySize(gameWidth, gameHeight)
            .setDepth(0);

          // [1] ìƒë‹¨ ë¬¸ì œíŒ
          const boardY = 130;
          this.quizBoard = this.add
            .image(centerX, boardY, "quiz_board")
            .setOrigin(0.5)
            .setDepth(10);
          this.quizIcon = this.add
            .image(centerX - 800, boardY, "quiz_icon")
            .setOrigin(0.5)
            .setDepth(11);
          this.questionProblem = this.add
            .text(centerX + 50, boardY, "", {
              fontSize: "80px",
              fill: "#FFFFFF",
              fontStyle: "bold",
              fontFamily: "Arial",
              stroke: "#000000",
              strokeThickness: 6,
            })
            .setOrigin(0.5)
            .setDepth(12);

          // [2] í…Œì´ë¸”
          const tableY = 980;
          this.table = this.add
            .image(centerX, tableY, "table")
            .setOrigin(0.5, 1)
            .setScale(SCALE.TABLE)
            .setDepth(10);
          const tableSurfaceY = tableY - this.table.displayHeight * 0.85;

          // [3] ë§ë¡±ì´ & ê·¸ë¦‡
          this.malong = this.add
            .image(centerX - 200, tableSurfaceY + 70, "malong_default")
            .setOrigin(0.5, 1)
            .setScale(SCALE.MALONG)
            .setDepth(5);
          this.bowl = this.add
            .image(centerX + 100, tableSurfaceY, "bowl0")
            .setOrigin(0.5, 1)
            .setScale(SCALE.BOWL)
            .setDepth(11);

          // [4] íƒ€ì´ë¨¸
          const timerY = 960;
          this.timerBgGraphic = this.add
            .image(centerX, timerY, "timer_graphic")
            .setOrigin(0.5)
            .setScale(SCALE.TIMER)
            .setDepth(30);

          const bgWidth = this.timerBgGraphic.displayWidth;
          const bgHeight = this.timerBgGraphic.displayHeight;
          this.timerBarWidth = bgWidth * 0.95;
          this.timerBarHeight = bgHeight * 0.35;

          this.timerBar = this.add
            .rectangle(
              centerX - this.timerBarWidth / 2,
              timerY + 40,
              this.timerBarWidth,
              this.timerBarHeight,
              0x00ff00
            )
            .setOrigin(0, 0.5)
            .setDepth(31);

          // [5] READY í™”ë©´
          this.readyOverlay = this.add
            .rectangle(
              centerX,
              gameHeight / 2,
              gameWidth,
              gameHeight,
              0x000000,
              0.6
            )
            .setDepth(100);
          this.readyText = this.add
            .text(centerX, gameHeight / 2, "READY?", {
              fontSize: "150px",
              fill: "#FFFFFF",
              fontStyle: "bold",
              stroke: "#000000",
              strokeThickness: 10,
            })
            .setOrigin(0.5)
            .setDepth(101);

          this.time.delayedCall(3000, this.startGame, [], this);
          this.spawnPocketsWithQuestion(false);
          // Start í‘œê¸°ê°€ ì ê¹ ëœ¨ê³  ë¬¸ì œê°€ ì‹œì‘ë©ë‹ˆë‹¤.
        }

        startGame() {
          // ê²Œì„ì„ ì‹œì‘í•˜ëŠ” ë¶€ë¶„ì…ë‹ˆë‹¤.
          this.isGameStarted = true;
          this.readyOverlay.destroy();
          this.readyText.destroy();
          // ready ê¸€ì”¨ê°€ ë„ì›Œì§€ëŠ” ì°½ì„ ì§€ì›ë‹ˆë‹¤.

          this.pockets.forEach((p) => {
            p.setVisible(true);
            if (p.label) p.label.setVisible(true);
          });
          this.setupTimers();
          // ëª¨ë“  ì»´í¬ë„ŒíŠ¸ë“¤ì„ ë³´ì´ê²Œ í•˜ê³ , íƒ€ì´ë¨¸ë¥¼ ì„¸íŒ…í•©ë‹ˆë‹¤.
        }

        setupTimers() {
          this.time.addEvent({
            delay: 1000,
            callback: () => {
              // íƒ€ì´ë¨¸ì˜ ìœ„ì¹˜ì™€ í¬ê¸°ë¥¼ ì§€ì •í•˜ëŠ” ë¶€ë¶„ì…ë‹ˆë‹¤.
              if (!this.isGameStarted || this.isGameOver) return;
              this.gameTimer--;
              this.timerBar.scaleX = this.gameTimer / this.gameTime;
              if (this.timerBar.scaleX <= 0.3)
                this.timerBar.setFillStyle(0xff0000);
            },
            loop: true,
          });
          this.time.delayedCall(this.gameTime * 1000, this.endGame, [], this);
        }

        generateMathQuestion() {
          // ì¼ë‹¨ ê¸°ë³¸ì ìœ¼ë¡œ ì‚¬ì¹™ì—°ì‚° ë¬¸ì œë¥¼ ìƒì„±í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
          const num1 = Phaser.Math.Between(1, 15);
          const num2 = Phaser.Math.Between(1, 15);
          const operators = ["+", "-", "*"];
          const operator = Phaser.Utils.Array.GetRandom(operators);
          let answer = 0;
          let qStr = "";
          switch (operator) {
            case "+":
              answer = num1 + num2;
              qStr = `${num1} + ${num2}`;
              break;
            case "-":
              answer = num1 - num2;
              qStr = `${num1} - ${num2}`;
              break;
            case "*":
              answer = num1 * num2;
              qStr = `${num1} * ${num2}`;
              break;
          }
          const options = [answer];
          while (options.length < 4) {
            let d = answer + Phaser.Math.Between(-10, 10);
            if (d >= 0 && d !== answer && !options.includes(d)) options.push(d);
          }
          Phaser.Utils.Array.Shuffle(options);
          return { question: qStr, answer: answer, options: options };
        }

        spawnPocketsWithQuestion(showPockets = true) {
          if (this.isGameOver) return;

          // ğŸ’¡ [ì•ˆì „ì¥ì¹˜ 1] í”Œë˜ê·¸ í•´ì œ (ìƒˆ ë¼ìš´ë“œ ì‹œì‘)
          this.isProcessingTurn = false;

          // ğŸ’¡ [ì•ˆì „ì¥ì¹˜ 2] ì•ˆì „í•˜ê²Œ ê°ì²´ ì‚­ì œ (Try-Catch & ì• ë‹ˆë©”ì´ì…˜ ì œê±°)
          try {
            this.pockets.forEach((p) => {
              if (p) {
                this.tweens.killTweensOf(p); // ì—°ê²°ëœ ì• ë‹ˆë©”ì´ì…˜ ê°•ì œ ì¢…ë£Œ
                if (p.label) p.label.destroy();
                p.destroy();
              }
            });
          } catch (e) {
            console.log("ê°ì²´ ì‚­ì œ ì¤‘ ì—ëŸ¬ ë¬´ì‹œ");
          }
          this.pockets = [];

          const qData = this.generateMathQuestion();
          // í•¨ìˆ˜ë¡œ ë¬¸ì œë¥¼ ë§Œë“¤ì–´ì„œ qDataì— ë„£ìŠµë‹ˆë‹¤.

          this.questionProblem.setText(`${qData.question} = ?`);
          this.currentAnswer = qData.answer;
          // ë¬¸ì œ ë¶€ë¶„ê³¼ í˜„ì¬ ë‹µ ë¶€ë¶„ì„ ì •í•©ë‹ˆë‹¤.

          let isSpecial = this.consecutiveCorrect >= 5;
          if (isSpecial) this.consecutiveCorrect = 0;

          const pocketY = 450;
          for (let i = 0; i < 4; i++) {
            const xPos = (this.cameras.main.width / 5) * (i + 1);
            let pKey = isSpecial ? "goodPack_lock" : "defaultPack_lock";
            const pocket = this.add
              .sprite(xPos, pocketY, pKey)
              .setOrigin(0.5)
              .setInteractive({ useHandCursor: true })
              .setVisible(showPockets)
              .setScale(SCALE.POCKET)
              .setDepth(15);

            pocket.label = this.add
              .text(xPos, pocketY + 40, qData.options[i], {
                fontSize: "60px",
                fill: "#000000",
                fontStyle: "bold",
              })
              .setOrigin(0.5)
              .setVisible(showPockets)
              .setDepth(16);

            if (isSpecial) {
              this.tweens.add({
                targets: [pocket],
                scale: SCALE.POCKET * 1.1,
                duration: 400,
                yoyo: true,
                repeat: -1,
                ease: "Sine.easeInOut",
              });
            }

            pocket.setData("value", qData.options[i]);
            pocket.setData("isSpecial", isSpecial);
            pocket.on("pointerdown", () => {
              this.onPocketClicked(pocket);
            });
            this.pockets.push(pocket);
          }
          // ì£¼ë¨¸ë‹ˆ ìœ„ì— í…ìŠ¤íŠ¸ê°€ ì˜¬ë¼ê°€ìˆë„ë¡ í•˜ê³ , ë§ëŠ” ì£¼ë¨¸ë‹ˆë¥¼ ì¶œë ¥í•˜ëŠ” ë¶€ë¶„ì…ë‹ˆë‹¤.
        }

        onPocketClicked(clickedPocket) {
          // ì£¼ë¨¸ë‹ˆë¥¼ í´ë¦­í•œ ê²½ìš°ë¥¼ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
          // ğŸ’¡ [ì•ˆì „ì¥ì¹˜ 3] ì¤‘ë³µ í´ë¦­ & ì§„í–‰ ì¤‘ í´ë¦­ ì™„ë²½ ì°¨ë‹¨
          if (!this.isGameStarted || this.isGameOver || this.isProcessingTurn)
            return;
          this.isProcessingTurn = true; // ì ê¸ˆ

          this.pockets.forEach((p) => {
            p.disableInteractive();
            if (p === clickedPocket) {
              p.setTexture(
                p.getData("isSpecial") ? "goodPack_open" : "defaultPack_open"
              );
              if (p.label) p.label.setVisible(false);
              this.tweens.killTweensOf(p); // í´ë¦­ëœ ì£¼ë¨¸ë‹ˆ ì• ë‹ˆë©”ì´ì…˜ ë©ˆì¶¤
              p.setScale(SCALE.POCKET);
            } else {
              p.setAlpha(0.5);
            }
          });

          const val = clickedPocket.getData("value");
          const isSpecial = clickedPocket.getData("isSpecial");

          if (val === this.currentAnswer)
            // ë‹µì„ ë§ì·„ìœ¼ë©´ handleCorrect í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
            this.handleCorrect(isSpecial, clickedPocket);
          else this.handleIncorrect(); // ë‹µì„ í‹€ë ¸ìœ¼ë©´ handleIncorrect í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.

          this.time.delayedCall(
            1000,
            this.spawnPocketsWithQuestion,
            [true],
            this
          );
        }

        handleCorrect(isSpecial, pocket) {
          // ë§ëŠ” ì£¼ë¨¸ë‹ˆë¥¼ ì„ íƒí•œ ê²½ìš°
          this.score += isSpecial ? 3 : 1;
          this.fruitStep++; // ğŸ’¡ ê³¼ì¼ ë‹¨ê³„ 1 ì¦ê°€
          this.consecutiveCorrect++;

          let fIdx = Math.min(this.fruitStep, 15);
          let fKey = `fruit${fIdx}`;

          // ğŸ’¡ [ì•ˆì „ì¥ì¹˜] ì´ë¯¸ì§€ê°€ ì¡´ì¬í•  ë•Œë§Œ ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰
          if (this.textures.exists(fKey)) {
            const flyingFruit = this.add
              .sprite(pocket.x, pocket.y - 50, fKey)
              .setScale(0)
              .setDepth(30);
            this.tweens.add({
              targets: flyingFruit,
              x: this.bowl.x,
              y: this.bowl.y - 100,
              scale: 1.0,
              duration: 600,
              ease: "Back.easeOut",
              onComplete: () => {
                if (flyingFruit.active) flyingFruit.destroy(); // ì•ˆì „í•˜ê²Œ ì‚­ì œ
                this.updateBowlGraphic();
              },
            });
          } else {
            this.updateBowlGraphic();
          }

          this.updateMalongStatus("happy"); // ë§ë¡±ì´ëŠ” ê¸°ë»í•©ë‹ˆë‹¤.
          this.time.delayedCall(1000, () => {
            this.updateMalongStatus("default");
          });
        }

        handleIncorrect() {
          // ì£¼ë¨¸ë‹ˆë¥¼ ì˜ ëª»ê³ ë¥´ë©´ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
          this.updateMalongStatus("sad"); // ë§ë¡±ì´ëŠ” ìŠ¬í¼í•©ë‹ˆë‹¤.
          this.consecutiveCorrect = 0;
          this.time.delayedCall(800, () => {
            this.updateMalongStatus("default");
          });
        }

        updateBowlGraphic() {
          // ê·¸ë¦‡ì˜ ìƒíƒœë¥¼ ê°±ì‹ í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
          // ğŸ’¡ ê³¼ì¼ ë‹¨ê³„(fruitStep) ê¸°ì¤€ìœ¼ë¡œ ì´ë¯¸ì§€ ë³€ê²½
          let bKey = `bowl${Math.min(this.fruitStep, 15)}`;
          if (this.textures.exists(bKey)) {
            this.bowl.setTexture(bKey);
          }
        }

        updateMalongStatus(state) {
          // ë§ë¡±ì´ì˜ ê¸°ë¶„ì„ ì¡°ì ˆí•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
          if (this.isGameOver) return;
          if (state === "happy") this.malong.setTexture("malong_happy");
          else if (state === "sad") this.malong.setTexture("malong_sad");
          else this.malong.setTexture("malong_default");
        }

        endGame() {
          // ê²Œì„ì´ ëë‚¬ì„ ë•Œ, ê³¼ì¼ ê°¯ìˆ˜ë¥¼ ì¶œë ¥í•˜ê³  finishì™€ ì»´í¬ë„ŒíŠ¸ ì‚­ì œë¥¼ í•˜ëŠ” í•¨ìˆ˜ì…ë‹ˆë‹¤.
          this.isGameStarted = false;
          this.isGameOver = true;
          this.isProcessingTurn = true; // ê²Œì„ ì¢…ë£Œ ì‹œ í´ë¦­ ì ê¸ˆ

          this.updateMalongStatus("happy");
          this.timerBgGraphic.setVisible(false);
          this.timerBar.setVisible(false);
          this.quizBoard.setVisible(false);
          this.quizIcon.setVisible(false);
          this.questionProblem.setVisible(false);

          // ğŸ’¡ ì¢…ë£Œ ì‹œ ì•ˆì „í•˜ê²Œ ì‚­ì œ
          this.pockets.forEach((p) => {
            if (p) {
              this.tweens.killTweensOf(p);
              if (p.label) p.label.destroy();
              p.destroy();
            }
          });
          this.pockets = [];

          const scoreText = this.add
            .text(this.bowl.x, 400, `ê³¼ì¼ ${this.score}ê°œ!`, {
              fontSize: "100px",
              fill: "#FFFF00",
              fontStyle: "bold",
              stroke: "#000000",
              strokeThickness: 8,
            })
            .setOrigin(0.5);

          this.time.delayedCall(
            3000,
            () => {
              scoreText.setVisible(false);
              this.add
                .rectangle(
                  this.cameras.main.width / 2,
                  this.cameras.main.height / 2,
                  this.cameras.main.width,
                  this.cameras.main.height,
                  0x000000,
                  0.6
                )
                .setDepth(100);
              this.add
                .text(
                  this.cameras.main.width / 2,
                  this.cameras.main.height / 2,
                  "FINISH!",
                  { fontSize: "150px", fill: "#FFFFFF", fontStyle: "bold" }
                )
                .setOrigin(0.5)
                .setDepth(101);
            },
            [],
            this
          );
        }
      }

      const config = {
        type: Phaser.AUTO,
        backgroundColor: "#000000",
        scale: {
          mode: Phaser.Scale.FIT,
          autoCenter: Phaser.Scale.CENTER_BOTH,
          width: 1920,
          height: 1080,
        },
        scene: [GameScene],
      };
      const game = new Phaser.Game(config);
    </script>
  </body>
</html>
