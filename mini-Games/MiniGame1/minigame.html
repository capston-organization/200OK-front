<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>ÎßêÎ°±Ïù¥Ïùò Í≥ºÏùº Ï∞æÍ∏∞ (Î∞∞Ïπò Ïú†ÏßÄ + Î≤ÑÍ∑∏ ÏàòÏ†ï)</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        background: #000;
      }
    </style>
  </head>
  <body>
    <script>
      const SCALE = {
        POCKET: 1.0,
        MALONG: 1.0,
        BOWL: 1.0,
        TABLE: 1.0,
        TIMER: 1.0,
      };

      class GameScene extends Phaser.Scene {
        constructor() {
          super("GameScene");
          this.score = 0;
          this.gameTime = 40;
          this.gameTimer = 40;
          this.isGameStarted = false;
          this.isGameOver = false;
          this.pockets = [];
          this.currentAnswer = 0;
          this.consecutiveCorrect = 0;
          this.isProcessingTurn = false; // üí° Ï§ëÎ≥µ ÌÅ¥Î¶≠ Î∞©ÏßÄ ÌîåÎûòÍ∑∏
          this.fruitStep = 0; // üí° Í≥ºÏùº Îã®Í≥Ñ Î≥ÄÏàò
        }

        preload() {
          this.load.setPath("assets/Sprites/");

          this.load.image("background", "Background.png");
          this.load.image("quiz_board", "QuizBoard.png");
          this.load.image("quiz_icon", "QuizIcon.png");
          this.load.image("timer_graphic", "timerGraphic.png");
          this.load.image("table", "table.png");

          this.load.image("malong_default", "malong_default.png");
          this.load.image("malong_sad", "malong_sad.png");
          this.load.image("malong_happy", "malong_happy.png");

          this.load.image("defaultPack_lock", "defaultPack_lock.png");
          this.load.image("defaultPack_open", "defaultPack_open.png");
          this.load.image("goodPack_lock", "goodPack_lock.png");
          this.load.image("goodPack_open", "goodPack_open.png");

          this.load.image("bowl0", "bowl0.png");
          for (let i = 1; i <= 15; i++) {
            this.load.image(`bowl${i}`, `bowl${i}.png`);
            this.load.image(`fruit${i}`, `fruit${i}.png`);
          }
        }

        create() {
          const gameWidth = 1920;
          const gameHeight = 1080;
          const centerX = gameWidth / 2;

          // 1. Î∞∞Í≤Ω
          this.add
            .image(centerX, gameHeight / 2, "background")
            .setDisplaySize(gameWidth, gameHeight)
            .setDepth(0);

          // [1] ÏÉÅÎã® Î¨∏Ï†úÌåê
          const boardY = 130;
          this.quizBoard = this.add
            .image(centerX, boardY, "quiz_board")
            .setOrigin(0.5)
            .setDepth(10);
          this.quizIcon = this.add
            .image(centerX - 800, boardY, "quiz_icon")
            .setOrigin(0.5)
            .setDepth(11);
          this.questionProblem = this.add
            .text(centerX + 50, boardY, "", {
              fontSize: "80px",
              fill: "#FFFFFF",
              fontStyle: "bold",
              fontFamily: "Arial",
              stroke: "#000000",
              strokeThickness: 6,
            })
            .setOrigin(0.5)
            .setDepth(12);

          // [2] ÌÖåÏù¥Î∏î
          const tableY = 980;
          this.table = this.add
            .image(centerX, tableY, "table")
            .setOrigin(0.5, 1)
            .setScale(SCALE.TABLE)
            .setDepth(10);
          const tableSurfaceY = tableY - this.table.displayHeight * 0.85;

          // [3] ÎßêÎ°±Ïù¥ & Í∑∏Î¶á
          this.malong = this.add
            .image(centerX - 200, tableSurfaceY + 70, "malong_default")
            .setOrigin(0.5, 1)
            .setScale(SCALE.MALONG)
            .setDepth(5);
          this.bowl = this.add
            .image(centerX + 100, tableSurfaceY, "bowl0")
            .setOrigin(0.5, 1)
            .setScale(SCALE.BOWL)
            .setDepth(11);

          // [4] ÌÉÄÏù¥Î®∏
          const timerY = 960;
          this.timerBgGraphic = this.add
            .image(centerX, timerY, "timer_graphic")
            .setOrigin(0.5)
            .setScale(SCALE.TIMER)
            .setDepth(30);

          const bgWidth = this.timerBgGraphic.displayWidth;
          const bgHeight = this.timerBgGraphic.displayHeight;
          this.timerBarWidth = bgWidth * 0.95;
          this.timerBarHeight = bgHeight * 0.35;

          this.timerBar = this.add
            .rectangle(
              centerX - this.timerBarWidth / 2,
              timerY + 40,
              this.timerBarWidth,
              this.timerBarHeight,
              0x00ff00
            )
            .setOrigin(0, 0.5)
            .setDepth(31);

          // [5] READY ÌôîÎ©¥
          this.readyOverlay = this.add
            .rectangle(
              centerX,
              gameHeight / 2,
              gameWidth,
              gameHeight,
              0x000000,
              0.6
            )
            .setDepth(100);
          this.readyText = this.add
            .text(centerX, gameHeight / 2, "READY?", {
              fontSize: "150px",
              fill: "#FFFFFF",
              fontStyle: "bold",
              stroke: "#000000",
              strokeThickness: 10,
            })
            .setOrigin(0.5)
            .setDepth(101);

          this.time.delayedCall(3000, this.startGame, [], this);
          this.spawnPocketsWithQuestion(false);
        }

        startGame() {
          this.isGameStarted = true;
          this.readyOverlay.destroy();
          this.readyText.destroy();
          this.pockets.forEach((p) => {
            p.setVisible(true);
            if (p.label) p.label.setVisible(true);
          });
          this.setupTimers();
        }

        setupTimers() {
          this.time.addEvent({
            delay: 1000,
            callback: () => {
              if (!this.isGameStarted || this.isGameOver) return;
              this.gameTimer--;
              this.timerBar.scaleX = this.gameTimer / this.gameTime;
              if (this.timerBar.scaleX <= 0.3)
                this.timerBar.setFillStyle(0xff0000);
            },
            loop: true,
          });
          this.time.delayedCall(this.gameTime * 1000, this.endGame, [], this);
        }

        generateMathQuestion() {
          const num1 = Phaser.Math.Between(1, 15);
          const num2 = Phaser.Math.Between(1, 15);
          const operators = ["+", "-", "*"];
          const operator = Phaser.Utils.Array.GetRandom(operators);
          let answer = 0;
          let qStr = "";
          switch (operator) {
            case "+":
              answer = num1 + num2;
              qStr = `${num1} + ${num2}`;
              break;
            case "-":
              answer = num1 - num2;
              qStr = `${num1} - ${num2}`;
              break;
            case "*":
              answer = num1 * num2;
              qStr = `${num1} * ${num2}`;
              break;
          }
          const options = [answer];
          while (options.length < 4) {
            let d = answer + Phaser.Math.Between(-10, 10);
            if (d >= 0 && d !== answer && !options.includes(d)) options.push(d);
          }
          Phaser.Utils.Array.Shuffle(options);
          return { question: qStr, answer: answer, options: options };
        }

        spawnPocketsWithQuestion(showPockets = true) {
          if (this.isGameOver) return;

          // üí° [ÏïàÏ†ÑÏû•Ïπò 1] ÌîåÎûòÍ∑∏ Ìï¥Ï†ú (ÏÉà ÎùºÏö¥Îìú ÏãúÏûë)
          this.isProcessingTurn = false;

          // üí° [ÏïàÏ†ÑÏû•Ïπò 2] ÏïàÏ†ÑÌïòÍ≤å Í∞ùÏ≤¥ ÏÇ≠Ï†ú (Try-Catch & Ïï†ÎãàÎ©îÏù¥ÏÖò Ï†úÍ±∞)
          try {
            this.pockets.forEach((p) => {
              if (p) {
                this.tweens.killTweensOf(p); // Ïó∞Í≤∞Îêú Ïï†ÎãàÎ©îÏù¥ÏÖò Í∞ïÏ†ú Ï¢ÖÎ£å
                if (p.label) p.label.destroy();
                p.destroy();
              }
            });
          } catch (e) {
            console.log("Í∞ùÏ≤¥ ÏÇ≠Ï†ú Ï§ë ÏóêÎü¨ Î¨¥Ïãú");
          }
          this.pockets = [];

          const qData = this.generateMathQuestion();
          this.questionProblem.setText(`${qData.question} = ?`);
          this.currentAnswer = qData.answer;

          let isSpecial = this.consecutiveCorrect >= 5;
          if (isSpecial) this.consecutiveCorrect = 0;

          const pocketY = 450;
          for (let i = 0; i < 4; i++) {
            const xPos = (this.cameras.main.width / 5) * (i + 1);
            let pKey = isSpecial ? "goodPack_lock" : "defaultPack_lock";
            const pocket = this.add
              .sprite(xPos, pocketY, pKey)
              .setOrigin(0.5)
              .setInteractive({ useHandCursor: true })
              .setVisible(showPockets)
              .setScale(SCALE.POCKET)
              .setDepth(15);

            pocket.label = this.add
              .text(xPos, pocketY + 40, qData.options[i], {
                fontSize: "60px",
                fill: "#000000",
                fontStyle: "bold",
              })
              .setOrigin(0.5)
              .setVisible(showPockets)
              .setDepth(16);

            if (isSpecial) {
              this.tweens.add({
                targets: [pocket],
                scale: SCALE.POCKET * 1.1,
                duration: 400,
                yoyo: true,
                repeat: -1,
                ease: "Sine.easeInOut",
              });
            }

            pocket.setData("value", qData.options[i]);
            pocket.setData("isSpecial", isSpecial);
            pocket.on("pointerdown", () => {
              this.onPocketClicked(pocket);
            });
            this.pockets.push(pocket);
          }
        }

        onPocketClicked(clickedPocket) {
          // üí° [ÏïàÏ†ÑÏû•Ïπò 3] Ï§ëÎ≥µ ÌÅ¥Î¶≠ & ÏßÑÌñâ Ï§ë ÌÅ¥Î¶≠ ÏôÑÎ≤Ω Ï∞®Îã®
          if (!this.isGameStarted || this.isGameOver || this.isProcessingTurn)
            return;
          this.isProcessingTurn = true; // Ïû†Í∏à

          this.pockets.forEach((p) => {
            p.disableInteractive();
            if (p === clickedPocket) {
              p.setTexture(
                p.getData("isSpecial") ? "goodPack_open" : "defaultPack_open"
              );
              if (p.label) p.label.setVisible(false);
              this.tweens.killTweensOf(p); // ÌÅ¥Î¶≠Îêú Ï£ºÎ®∏Îãà Ïï†ÎãàÎ©îÏù¥ÏÖò Î©àÏ∂§
              p.setScale(SCALE.POCKET);
            } else {
              p.setAlpha(0.5);
            }
          });

          const val = clickedPocket.getData("value");
          const isSpecial = clickedPocket.getData("isSpecial");

          if (val === this.currentAnswer)
            this.handleCorrect(isSpecial, clickedPocket);
          else this.handleIncorrect();

          this.time.delayedCall(
            1000,
            this.spawnPocketsWithQuestion,
            [true],
            this
          );
        }

        handleCorrect(isSpecial, pocket) {
          this.score += isSpecial ? 3 : 1;
          this.fruitStep++; // üí° Í≥ºÏùº Îã®Í≥Ñ 1 Ï¶ùÍ∞Ä
          this.consecutiveCorrect++;

          let fIdx = Math.min(this.fruitStep, 15);
          let fKey = `fruit${fIdx}`;

          // üí° [ÏïàÏ†ÑÏû•Ïπò] Ïù¥ÎØ∏ÏßÄÍ∞Ä Ï°¥Ïû¨Ìï† ÎïåÎßå Ïï†ÎãàÎ©îÏù¥ÏÖò Ïã§Ìñâ
          if (this.textures.exists(fKey)) {
            const flyingFruit = this.add
              .sprite(pocket.x, pocket.y - 50, fKey)
              .setScale(0)
              .setDepth(30);
            this.tweens.add({
              targets: flyingFruit,
              x: this.bowl.x,
              y: this.bowl.y - 100,
              scale: 1.0,
              duration: 600,
              ease: "Back.easeOut",
              onComplete: () => {
                if (flyingFruit.active) flyingFruit.destroy(); // ÏïàÏ†ÑÌïòÍ≤å ÏÇ≠Ï†ú
                this.updateBowlGraphic();
              },
            });
          } else {
            this.updateBowlGraphic();
          }

          this.updateMalongStatus("happy");
          this.time.delayedCall(1000, () => {
            this.updateMalongStatus("default");
          });
        }

        handleIncorrect() {
          this.updateMalongStatus("sad");
          this.consecutiveCorrect = 0;
          this.time.delayedCall(800, () => {
            this.updateMalongStatus("default");
          });
        }

        updateBowlGraphic() {
          // üí° Í≥ºÏùº Îã®Í≥Ñ(fruitStep) Í∏∞Ï§ÄÏúºÎ°ú Ïù¥ÎØ∏ÏßÄ Î≥ÄÍ≤Ω
          let bKey = `bowl${Math.min(this.fruitStep, 15)}`;
          if (this.textures.exists(bKey)) {
            this.bowl.setTexture(bKey);
          }
        }

        updateMalongStatus(state) {
          if (this.isGameOver) return;
          if (state === "happy") this.malong.setTexture("malong_happy");
          else if (state === "sad") this.malong.setTexture("malong_sad");
          else this.malong.setTexture("malong_default");
        }

        endGame() {
          this.isGameStarted = false;
          this.isGameOver = true;
          this.isProcessingTurn = true; // Í≤åÏûÑ Ï¢ÖÎ£å Ïãú ÌÅ¥Î¶≠ Ïû†Í∏à

          this.updateMalongStatus("happy");
          this.timerBgGraphic.setVisible(false);
          this.timerBar.setVisible(false);
          this.quizBoard.setVisible(false);
          this.quizIcon.setVisible(false);
          this.questionProblem.setVisible(false);

          // üí° Ï¢ÖÎ£å Ïãú ÏïàÏ†ÑÌïòÍ≤å ÏÇ≠Ï†ú
          this.pockets.forEach((p) => {
            if (p) {
              this.tweens.killTweensOf(p);
              if (p.label) p.label.destroy();
              p.destroy();
            }
          });
          this.pockets = [];

          const scoreText = this.add
            .text(this.bowl.x, 400, `Í≥ºÏùº ${this.score}Í∞ú!`, {
              fontSize: "100px",
              fill: "#FFFF00",
              fontStyle: "bold",
              stroke: "#000000",
              strokeThickness: 8,
            })
            .setOrigin(0.5);

          this.time.delayedCall(
            3000,
            () => {
              scoreText.setVisible(false);
              this.add
                .rectangle(
                  this.cameras.main.width / 2,
                  this.cameras.main.height / 2,
                  this.cameras.main.width,
                  this.cameras.main.height,
                  0x000000,
                  0.6
                )
                .setDepth(100);
              this.add
                .text(
                  this.cameras.main.width / 2,
                  this.cameras.main.height / 2,
                  "FINISH!",
                  { fontSize: "150px", fill: "#FFFFFF", fontStyle: "bold" }
                )
                .setOrigin(0.5)
                .setDepth(101);
            },
            [],
            this
          );
        }
      }

      const config = {
        type: Phaser.AUTO,
        backgroundColor: "#000000",
        scale: {
          mode: Phaser.Scale.FIT,
          autoCenter: Phaser.Scale.CENTER_BOTH,
          width: 1920,
          height: 1080,
        },
        scene: [GameScene],
      };
      const game = new Phaser.Game(config);
    </script>
  </body>
</html>
